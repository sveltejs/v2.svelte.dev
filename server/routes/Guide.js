'use strict';

var contents = [{"html":"<h3 id=\"what-is-svelte-\">What is Svelte?</h3>\n<p>If you&#39;ve ever built a JavaScript application, the chances are you&#39;ve encountered â€“ or at least heard of â€“ frameworks like React, Angular, Vue and Ractive. Like Svelte, these tools all share a goal of making it easy to build slick interactive user interfaces.</p>\n<p>But Svelte has a crucial difference: rather than interpreting your application code at <em>run time</em>, your app is converted into ideal JavaScript at <em>build time</em>. That means you don&#39;t pay the performance cost of the framework&#39;s abstractions, or incur a penalty when your app first loads.</p>\n<p>And because there&#39;s no overhead, you can easily adopt Svelte in an existing app incrementally, or ship widgets as standalone packages that work anywhere.</p>\n<p><a href=\"/blog/frameworks-without-the-framework/\">Read the introductory blog post</a> to learn more about Svelte&#39;s goals and philosophy.</p>\n<h3 id=\"understanding-svelte-components\">Understanding Svelte components</h3>\n<p>In Svelte, an application is composed from one or more <em>components</em>. A component is a reusable self-contained block of code that encapsulates markup, styles and behaviours that belong together.</p>\n<p>Like Ractive and Vue, Svelte promotes the concept of <em>single-file components</em>: a component is just an <code>.html</code> file. Here&#39;s a simple example:</p>\n<pre><code class=\"lang-html\">&lt;!-- App.html --&gt;\n&lt;h1&gt;Hello {{name}}!&lt;/h1&gt;\n</code></pre>\n<pre><code class=\"lang-hidden-data\">{\n  &quot;name&quot;: &quot;world&quot;\n}\n</code></pre>\n<p>Svelte turns this into a JavaScript module that you can import into your app:</p>\n<pre><code class=\"lang-js\">// main.js\nimport App from &#39;./App.html&#39;;\n\nconst app = new App({\n  target: document.querySelector( &#39;main&#39; ),\n  data: { name: &#39;world&#39; }\n});\n\n// change the data associated with the template\napp.set({ name: &#39;everybody&#39; });\n\n// detach the component and clean everything up\napp.teardown();\n</code></pre>\n<p>Congratulations, you&#39;ve just learned about half of Svelte&#39;s API!</p>\n<h3 id=\"getting-started\">Getting started</h3>\n<p>Normally, this is the part where the instructions might tell you to add the framework to your page as a <code>&lt;script&gt;</code> tag. But because Svelte runs at build time, it works a little bit differently.</p>\n<p>The best way to use Svelte is to integrate it into your build system â€“ there are plugins for Rollup, Browserify, Gulp and others, with more on the way. See <a href=\"https://github.com/sveltejs/svelte/#svelte\">here</a> for an up-to-date list.</p>\n<p>Right now, for the purposes of demonstration, we&#39;ll use <a href=\"https://github.com/sveltejs/svelte-cli\">svelte-cli</a>, the command line interface.</p>\n<blockquote>\n<p>You will need to have <a href=\"https://nodejs.org/en/\">Node.js</a> installed, and have some familiarity with the command line</p>\n</blockquote>\n<p>First, install the CLI:</p>\n<pre><code class=\"lang-bash\">npm install -g svelte-cli\n</code></pre>\n<p>Then, create a directory for the project:</p>\n<pre><code class=\"lang-bash\">mkdir my-svelte-project\ncd my-svelte-project\n</code></pre>\n<p>Inside <code>my-svelte-project</code>, create a <code>HelloWorld.html</code> file with the following contents:</p>\n<pre><code class=\"lang-html\">&lt;h1&gt;Hello {{name}}&lt;/h1&gt;\n</code></pre>\n<p>Compile it:</p>\n<pre><code class=\"lang-bash\">svelte compile --format iife HelloWorld.html &gt; HelloWorld.js\n</code></pre>\n<p>The <code>--format iife</code> bit means &#39;generate an immediately-invoked function expression&#39; â€“ this allows us to use the component as a simple <code>&lt;script&gt;</code> tag. (By default, Svelte will create a JavaScript module instead, which is recommended for more serious applications but requires additional steps.)</p>\n<p>Create an <code>index.html</code> page and include the script we just generated:</p>\n<pre><code class=\"lang-html\">&lt;!doctype html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;My first Svelte app&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;main&gt;&lt;/main&gt;\n  &lt;script src=&#39;HelloWorld.js&#39;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    var app = new HelloWorld({\n      target: document.querySelector( &#39;main&#39; ),\n      data: {\n        name: &#39;world&#39;\n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>Finally, open the page in your browser â€“ <code>open index.html</code> â€“ and interact with <code>app</code> via the console using the API.</p>\n","metadata":{"title":"Introduction"},"subsections":[{"slug":"what-is-svelte-","title":"What is Svelte?"},{"slug":"understanding-svelte-components","title":"Understanding Svelte components"},{"slug":"getting-started","title":"Getting started"}],"slug":"introduction"},{"html":"<p>As we saw above, you create a component instance with the <code>new</code> keyword:</p>\n<pre><code class=\"lang-js\">import MyComponent from &#39;./MyComponent.html&#39;;\n\nconst component = new MyComponent({\n  // `target` is the only required option â€“ the element\n  // to render the component to\n  target: document.querySelector( &#39;main&#39; ),\n\n  // `data` is optional. A component can also have\n  // default data â€“ we&#39;ll learn about that later.\n  data: {\n    questions: [\n      &#39;life&#39;,\n      &#39;the universe&#39;,\n      &#39;everything&#39;\n    ],\n    answer: 42\n  }\n});\n</code></pre>\n<p>Every Svelte component instance has a small number of methods you can use to control it, in addition to any <a href=\"#custom-methods\">custom methods</a> you add.</p>\n<h3 id=\"component-set-data-\">component.set(data)</h3>\n<p>This updates the component&#39;s state with the new values provided and causes the DOM to update. <code>data</code> must be a plain old JavaScript object (POJO). Any properties <em>not</em> included in <code>data</code> will remain as they were.</p>\n<pre><code class=\"lang-js\">component.set({\n  questions: [\n    &#39;why is the sky blue?&#39;,\n    &#39;how do planes fly?&#39;,\n    &#39;where do babies come from?&#39;\n  ],\n  answer: &#39;ask your mother&#39;\n});\n</code></pre>\n<blockquote>\n<p>If you&#39;ve used Ractive in the past, this is very similar to <code>ractive.set(...)</code>, except that instead of doing <code>ractive.set(&#39;foo&#39;, &#39;bar&#39;)</code> you must always do <code>ractive.set({foo: &#39;bar&#39;})</code>, and you cannot set nested keypaths directly. It&#39;s also very similar to React&#39;s <code>setState</code>, except that it causes synchronous updates, meaning the DOM is always in a predictable state.</p>\n</blockquote>\n<h3 id=\"component-get-key-\">component.get(key)</h3>\n<p>Returns the current value of <code>key</code>:</p>\n<pre><code class=\"lang-js\">console.log( component.get( &#39;answer&#39; ) ); // &#39;ask your mother&#39;\n</code></pre>\n<p>This will also retrieve the value of <a href=\"#computed-properties\">computed properties</a>.</p>\n<h3 id=\"component-observe-key-callback-options-\">component.observe(key, callback[, options])</h3>\n<p>This method allows you to respond to changes in state, which is particularly useful when combined with <a href=\"#lifecycle-hooks\">lifecycle hooks</a> and <a href=\"#two-way-binding\">two-way bindings</a>.</p>\n<pre><code class=\"lang-js\">const observer = component.observe( &#39;answer&#39;, answer =&gt; {\n  console.log( `the answer is ${answer}` );\n});\n// fires immediately with current answer:\n// -&gt; &#39;the answer is ask your mother&#39;\n\ncomponent.set({ answer: &#39;google it&#39; });\n// -&gt; &#39;the answer is google it&#39;\n\nobserver.cancel(); // further changes will be ignored\n</code></pre>\n<p>The callback takes two arguments â€“ the current value and the previous value. (The first time it is called, the second argument will be <code>undefined</code>):</p>\n<pre><code class=\"lang-js\">thermometer.observe( &#39;temperature&#39;, ( newValue, oldValue ) =&gt; {\n  if ( oldValue === undefined ) return;\n  console.log( `it&#39;s getting ${newValue &gt; oldValue ? &#39;warmer&#39; : &#39;colder&#39;}` );\n});\n</code></pre>\n<p>If you don&#39;t want the callback to fire when you first attach the observer, use <code>init: false</code>:</p>\n<pre><code class=\"lang-js\">thermometer.observe( &#39;temperature&#39;, ( newValue, oldValue ) =&gt; {\n  console.log( `it&#39;s getting ${newValue &gt; oldValue ? &#39;warmer&#39; : &#39;colder&#39;}` );\n}, { init: false });\n</code></pre>\n<blockquote>\n<p>For <em>primitive</em> values like strings and numbers, observer callbacks are only called when the value changes. But because it&#39;s possible to mutate an object or array while preserving <em>referential equality</em>, Svelte will err on the side of caution. In other words, if you do <code>component.set({foo: component.get(&#39;foo&#39;)})</code>, and <code>foo</code> is an object or array, any <code>foo</code> observers will be triggered.</p>\n</blockquote>\n<p>By default, observers are called <em>before</em> the DOM updates, giving you a chance to perform any additional updates without touching the DOM more than is necessary. In some cases â€“ for example, if you need to measure an element after the DOM has been updated â€“ use <code>defer: true</code>:</p>\n<pre><code class=\"lang-js\">function redraw () {\n  canvas.width = drawingApp.get( &#39;width&#39; );\n  canvas.height = drawingApp.get( &#39;height&#39; );\n  updateCanvas();\n}\n\ndrawingApp.observe( &#39;width&#39;, redraw, { defer: true });\ndrawingApp.observe( &#39;height&#39;, redraw, { defer: true });\n</code></pre>\n<p>To observe on a nested component, use refs:</p>\n<pre><code class=\"lang-html-no-repl\">&lt;Widget ref:widget/&gt;\n&lt;script&gt;\n  export default {\n    onrender () {\n      this.refs.widget.observe( &#39;xxx&#39;, () =&gt; {...});\n    }\n  };\n&lt;/script&gt;\n</code></pre>\n<h3 id=\"component-on-eventname-callback-\">component.on(eventName, callback)</h3>\n<p>Allows you to respond to <em>events</em>:</p>\n<pre><code class=\"lang-js\">const listener = component.on( &#39;thingHappened&#39;, event =&gt; {\n  console.log( `A thing happened: ${event.thing}` );\n});\n\n// some time later...\nlistener.cancel();\n</code></pre>\n<h3 id=\"component-fire-eventname-event-\">component.fire(eventName, event)</h3>\n<p>The companion to <code>component.on(...)</code>:</p>\n<pre><code class=\"lang-js\">component.fire( &#39;thingHappened&#39;, {\n  thing: &#39;this event was fired&#39;\n});\n</code></pre>\n<p>At first glance <code>component.on(...)</code> and <code>component.fire(...)</code> aren&#39;t particularly useful, but it&#39;ll become more so when we learn about <a href=\"#nested-components\">nested components</a>.</p>\n<blockquote>\n<p><code>component.on(...)</code> and <code>component.observe(...)</code> look quite similar, but they have different purposes. Observers are useful for reacting to data flowing through your application and changing continuously over time, whereas events are good for modeling discrete moments such as &#39;the user made a selection, and this is what it is&#39;.</p>\n</blockquote>\n<h3 id=\"component-teardown-\">component.teardown()</h3>\n<p>Removes the component from the DOM and removes any observers and event listeners that were created. This will also fire a <code>teardown</code> event:</p>\n<pre><code class=\"lang-js\">component.on( &#39;teardown&#39;, () =&gt; {\n  alert( &#39;goodbye!&#39; ); // please don&#39;t do this\n});\n\ncomponent.teardown();\n</code></pre>\n","metadata":{"title":"Component API"},"subsections":[{"slug":"component-set-data-","title":"component.set"},{"slug":"component-get-key-","title":"component.get"},{"slug":"component-observe-key-callback-options-","title":"component.observe"},{"slug":"component-on-eventname-callback-","title":"component.on"},{"slug":"component-fire-eventname-event-","title":"component.fire"},{"slug":"component-teardown-","title":"component.teardown"}],"slug":"component-api"},{"html":"<p>Rather than reinventing the wheel, Svelte templates are built on foundations that have stood the test of time: HTML, CSS and JavaScript. There&#39;s very little extra stuff to learn.</p>\n<h3 id=\"tags\">Tags</h3>\n<p>Tags allow you to bind data to your template. Whenever your data changes (for example after <code>component.set(...)</code>), the DOM updates automatically. You can use any JavaScript expression in templates, and it will also automatically update:</p>\n<pre><code class=\"lang-html\">&lt;p&gt;{{a}} + {{b}} = {{a + b}}&lt;/p&gt;\n</code></pre>\n<pre><code class=\"lang-hidden-data\">{\n  &quot;a&quot;: 1,\n  &quot;b&quot;: 2\n}\n</code></pre>\n<p>You can also use tags in attributes:</p>\n<pre><code class=\"lang-html\">&lt;h1 style=&#39;color: {{color}};&#39;&gt;{{color}}&lt;/h1&gt;\n</code></pre>\n<pre><code class=\"lang-hidden-data\">{\n  &quot;color&quot;: &quot;steelblue&quot;\n}\n</code></pre>\n<blockquote>\n<p>While tags are delimited using <code>{{</code> and <code>}}</code>, Svelte does not use <a href=\"https://mustache.github.io/\">Mustache</a> syntax. Tags are just JavaScript expressions.</p>\n</blockquote>\n<h3 id=\"triples\">Triples</h3>\n<p>Ordinary tags render expressions as plain text. If you need your expression interpreted as HTML, wrap it in triple braces, <code>{{{</code> and <code>}}}</code>.</p>\n<pre><code class=\"lang-html\">&lt;p&gt;This HTML: {{html}}&lt;/p&gt;\n&lt;p&gt;Renders as: {{{html}}}&lt;/p&gt;\n</code></pre>\n<pre><code class=\"lang-hidden-data\">{\n  &quot;html&quot;: &quot;Some &lt;b&gt;bold&lt;/b&gt; text.&quot;\n}\n</code></pre>\n<p>As with tags, you can use any JavaScript expression in triples, and it will automatically update the document when your data changes.</p>\n<blockquote>\n<p>Triples will <strong>not</strong> sanitize the HTML before rendering it! If you are displaying user input, you are responsible for first sanitizing it. Not doing so opens you up to all sorts of different attacks.</p>\n</blockquote>\n<h3 id=\"if-blocks\">If blocks</h3>\n<p>Control whether or not part of your template is rendered by wrapping it in an if block.</p>\n<pre><code class=\"lang-html\">{{#if user.loggedIn}}\n  &lt;a href=&#39;/logout&#39;&gt;log out&lt;/a&gt;\n{{/if}}\n\n{{#if !user.loggedIn}}\n  &lt;a href=&#39;/login&#39;&gt;log in&lt;/a&gt;\n{{/if}}\n</code></pre>\n<pre><code class=\"lang-hidden-data\">{\n  &quot;user&quot;: { &quot;loggedIn&quot;: false }\n}\n</code></pre>\n<p>You can combine the two blocks above with <code>{{else}}</code>:</p>\n<pre><code class=\"lang-html\">{{#if user.loggedIn}}\n  &lt;a href=&#39;/logout&#39;&gt;log out&lt;/a&gt;\n{{else}}\n  &lt;a href=&#39;/login&#39;&gt;log in&lt;/a&gt;\n{{/if}}\n</code></pre>\n<pre><code class=\"lang-hidden-data\">{\n  &quot;user&quot;: { &quot;loggedIn&quot;: false }\n}\n</code></pre>\n<p>You can also use <code>{{elseif ...}}</code>:</p>\n<pre><code class=\"lang-html\">{{#if x &gt; 10}}\n  &lt;p&gt;{{x}} is greater than 10&lt;/p&gt;\n{{elseif 5 &gt; x}}\n  &lt;p&gt;{{x}} is less than 5&lt;/p&gt;\n{{else}}\n  &lt;p&gt;{{x}} is between 5 and 10&lt;/p&gt;\n{{/if}}\n</code></pre>\n<pre><code class=\"lang-hidden-data\">{\n  &quot;x&quot;: 7\n}\n</code></pre>\n<h3 id=\"each-blocks\">Each blocks</h3>\n<p>Iterate over lists of data:</p>\n<pre><code class=\"lang-html\">&lt;h1&gt;Cats of YouTube&lt;/h1&gt;\n\n&lt;ul&gt;\n  {{#each cats as cat}}\n    &lt;li&gt;&lt;a target=&#39;_blank&#39; href=&#39;{{cat.video}}&#39;&gt;{{cat.name}}&lt;/a&gt;&lt;/li&gt;\n  {{/each}}\n&lt;/ul&gt;\n</code></pre>\n<pre><code class=\"lang-hidden-data\">{\n  &quot;cats&quot;: [\n    {\n      &quot;name&quot;: &quot;Keyboard Cat&quot;,\n      &quot;video&quot;: &quot;https://www.youtube.com/watch?v=J---aiyznGQ&quot;\n    },\n    {\n      &quot;name&quot;: &quot;Maru&quot;,\n      &quot;video&quot;: &quot;https://www.youtube.com/watch?v=z_AbfPXTKms&quot;\n    },\n    {\n      &quot;name&quot;: &quot;Henri The Existential Cat&quot;,\n      &quot;video&quot;: &quot;https://www.youtube.com/watch?v=OUtn3pvWmpg&quot;\n    }\n  ]\n}\n</code></pre>\n<p>You can access the index of the current element with <em>expression</em> as <em>name</em>, <em>index</em>:</p>\n<pre><code class=\"lang-html\">&lt;div class=&#39;grid&#39;&gt;\n  {{#each rows as row, y}}\n    &lt;div class=&#39;row&#39;&gt;\n      {{#each columns as column, x}}\n        &lt;code class=&#39;cell&#39;&gt;\n          {{x + 1}},{{y + 1}}:\n          &lt;strong&gt;{{row[column]}}&lt;/strong&gt;\n        &lt;/code&gt;\n      {{/each}}\n    &lt;/div&gt;\n  {{/each}}\n&lt;/div&gt;\n</code></pre>\n<pre><code class=\"lang-hidden-data\">{\n  &quot;columns&quot;: [ &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot; ],\n  &quot;rows&quot;: [\n    { &quot;foo&quot;: &quot;a&quot;, &quot;bar&quot;: &quot;b&quot;, &quot;baz&quot;: &quot;c&quot; },\n    { &quot;foo&quot;: &quot;d&quot;, &quot;bar&quot;: &quot;e&quot;, &quot;baz&quot;: &quot;f&quot; },\n    { &quot;foo&quot;: &quot;g&quot;, &quot;bar&quot;: &quot;h&quot;, &quot;baz&quot;: &quot;i&quot; }\n  ]\n}\n</code></pre>\n<h3 id=\"directives\">Directives</h3>\n<p>The last place where Svelte template syntax differs from regular HTML: <em>directives</em> allow you to add special instructions for adding <a href=\"#event-handlers\">event handlers</a>, <a href=\"#two-way-binding\">two-way bindings</a>, <a href=\"#refs\">refs</a> and so on. We&#39;ll cover each of those in later stages of this guide â€“ for now, all you need to know is that directives can be identified by the <code>:</code> character:</p>\n<pre><code class=\"lang-html\">&lt;p&gt;Count: {{count}}&lt;/p&gt;\n&lt;button on:click=&#39;set({ count: count + 1 })&#39;&gt;+1&lt;/button&gt;\n</code></pre>\n<pre><code class=\"lang-hidden-data\">{\n  &quot;count&quot;: 0\n}\n</code></pre>\n<blockquote>\n<p>Technically, the <code>:</code> character is used to denote namespaced attributes in HTML. These will <em>not</em> be treated as directives, if encountered.</p>\n</blockquote>\n","metadata":{"title":"Template syntax"},"subsections":[{"slug":"tags","title":"Tags"},{"slug":"triples","title":"Triples"},{"slug":"if-blocks","title":"If blocks"},{"slug":"each-blocks","title":"Each blocks"},{"slug":"directives","title":"Directives"}],"slug":"template-syntax"},{"html":"<p>One of Svelte&#39;s key tenets is that components should be self-contained and reusable in different contexts. Because of that, it has a mechanism for <em>scoping</em> your CSS, so that you don&#39;t accidentally clobber other selectors on the page.</p>\n<h3 id=\"adding-styles\">Adding styles</h3>\n<p>Your component template can have a <code>&lt;style&gt;</code> tag, like so:</p>\n<pre><code class=\"lang-html\">&lt;div class=&#39;foo&#39;&gt;\n  Big red Comic Sans\n&lt;/div&gt;\n\n&lt;style&gt;\n  .foo {\n    color: red;\n    font-size: 2em;\n    font-family: &#39;Comic Sans MS&#39;;\n  }\n&lt;/style&gt;\n</code></pre>\n<h3 id=\"how-it-works\">How it works</h3>\n<p>Open the example above in the REPL and inspect the element to see what has happened â€“ Svelte has added a <code>svelte-[uniqueid]</code> attribute to the element, and transformed the CSS selector accordingly. Since no other element on the page can share that selector, anything else on the page with <code>class=&quot;foo&quot;</code> will be unaffected by our styles.</p>\n<p>This is vastly simpler than achieving the same effect via <a href=\"http://caniuse.com/#search=shadow%20dom\">Shadow DOM</a> and works everywhere without polyfills.</p>\n<blockquote>\n<p>Svelte will add a <code>&lt;style&gt;</code> tag to the page containing your scoped styles. Dynamically adding styles may be impossible if your site has a <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP\">Content Security Policy</a>. If that&#39;s the case, you can use scoped styles by <a href=\"#rendering-css\">server-rendering your CSS</a> and using the <code>css: false</code> compiler option (or <code>--no-css</code> with the CLI).</p>\n</blockquote>\n<h3 id=\"cascading-rules\">Cascading rules</h3>\n<p>The usual cascading mechanism still applies â€“ any global <code>.foo</code> styles would still be applied, and if our template had <a href=\"#nested-components\">nested components</a> with <code>class=&quot;foo&quot;</code> elements, they would inherit our styles.</p>\n<blockquote>\n<p>Scoped styles are <em>not</em> dynamic â€“ they are shared between all instances of a component. In other words you can&#39;t use <code>{{tags}}</code> inside your CSS.</p>\n</blockquote>\n","metadata":{"title":"Scoped styles"},"subsections":[{"slug":"adding-styles","title":"Adding styles"},{"slug":"how-it-works","title":"How it works"},{"slug":"cascading-rules","title":"Cascading rules"}],"slug":"scoped-styles"},{"html":"<p>As well as scoped styles and a template, components can encapsulate <em>behaviours</em>. For that, we add a <code>&lt;script&gt;</code> element and export an object:</p>\n<pre><code class=\"lang-html\">&lt;div&gt;\n  &lt;!-- template goes here --&gt;\n&lt;/div&gt;\n\n&lt;script&gt;\n  export default {\n    // behaviours go here\n  };\n&lt;/script&gt;\n</code></pre>\n<h3 id=\"default-data\">Default data</h3>\n<p>Often, it makes sense for a component to have default data. This should be expressed as a function that returns a POJO:</p>\n<pre><code class=\"lang-html\">&lt;p&gt;Count: {{count}}&lt;/p&gt;\n&lt;button on:click=&#39;set({ count: count + 1 })&#39;&gt;+1&lt;/button&gt;\n\n&lt;script&gt;\n  export default {\n    data () {\n      return {\n        count: 0\n      };\n    }\n  };\n&lt;/script&gt;\n</code></pre>\n<p>Data supplied at instantiation (i.e. <code>new Component(...)</code>) takes priority over defaults.</p>\n<blockquote>\n<p>The example above, like many of the examples below, uses ES2015 syntax â€“ i.e. <code>data () {...}</code> rather than <code>data: function {...}</code>. While Svelte will generate ES5 code that runs everywhere, it <em>won&#39;t</em> convert your ES2015 code into ES5 â€“ so if you use ES2015 and need to support older browsers, you will need an additional transpilation step in your build process using <a href=\"https://babeljs.io\">Babel</a> or <a href=\"https://buble.surge.sh\">BublÃ©</a>.</p>\n</blockquote>\n<h3 id=\"computed-properties\">Computed properties</h3>\n<p>Often, your program will use values that depend on other values â€“ for example, you might have a filtered list, which depends on both the list <em>and</em> the filter. Normally in JavaScript you&#39;d have to add logic to update the dependent property when <em>any</em> of the dependencies change. This is a frequent source of bugs, and it gets worse as your application grows.</p>\n<p>Svelte allows you to express these dependencies in computed properties, which are recalculated whenever those dependencies change:</p>\n<pre><code class=\"lang-html\">&lt;p&gt;\n  The time is\n  &lt;strong&gt;{{hours}}:{{minutes}}:{{seconds}}&lt;/strong&gt;\n&lt;/p&gt;\n\n&lt;script&gt;\n  export default {\n    data () {\n      return {\n        time: new Date()\n      };\n    },\n\n    computed: {\n      hours: time =&gt; time.getHours(),\n      minutes: time =&gt; time.getMinutes(),\n      seconds: time =&gt; time.getSeconds()\n    }\n  };\n&lt;/script&gt;\n</code></pre>\n<p>Notice that all we need to do to tell Svelte that <code>hours</code>, <code>minutes</code> and <code>seconds</code> depend on <code>time</code> is include it as a parameter to the function. There&#39;s no costly dependency tracking involved â€“ the dependency graph is resolved at compile time.</p>\n<blockquote>\n<p><code>computed</code> must be an object literal, and the properties must be function expressions or arrow function expressions.</p>\n</blockquote>\n<h3 id=\"lifecycle-hooks\">Lifecycle hooks</h3>\n<p>There are two &#39;hooks&#39; provided by Svelte for adding control logic â€“ <code>oncreate</code> and <code>ondestroy</code>:</p>\n<pre><code class=\"lang-html\">&lt;p&gt;\n  The time is\n  &lt;strong&gt;{{hours}}:{{minutes}}:{{seconds}}&lt;/strong&gt;\n&lt;/p&gt;\n\n&lt;script&gt;\n  export default {\n    oncreate () {\n      this.interval = setInterval( () =&gt; {\n        this.set({ time: new Date() });\n      }, 1000 );\n    },\n\n    ondestroy () {\n      clearInterval( this.interval );\n    },\n\n    data () {\n      return {\n        time: new Date()\n      };\n    },\n\n    computed: {\n      hours: time =&gt; time.getHours(),\n      minutes: time =&gt; time.getMinutes(),\n      seconds: time =&gt; time.getSeconds()\n    }\n  };\n&lt;/script&gt;\n</code></pre>\n<h3 id=\"helpers\">Helpers</h3>\n<p>Helpers are simple functions that are used in your template. In the example above, we want to ensure that <code>minutes</code> and <code>seconds</code> are preceded with a <code>0</code> if they only have one digit, so we add a <code>leftPad</code> helper:</p>\n<pre><code class=\"lang-html\">&lt;p&gt;\n  The time is\n  &lt;strong&gt;{{hours}}:{{leftPad(minutes, 2, &#39;0&#39;)}}:{{leftPad(seconds, 2, &#39;0&#39;)}}&lt;/strong&gt;\n&lt;/p&gt;\n\n&lt;script&gt;\n  import leftPad from &#39;left-pad&#39;;\n\n  export default {\n    helpers: {\n      leftPad\n    },\n\n    oncreate () {\n      this.interval = setInterval( () =&gt; {\n        this.set({ time: new Date() });\n      }, 1000 );\n    },\n\n    ondestroy () {\n      clearInterval( this.interval );\n    },\n\n    data () {\n      return {\n        time: new Date()\n      };\n    },\n\n    computed: {\n      hours: time =&gt; time.getHours(),\n      minutes: time =&gt; time.getMinutes(),\n      seconds: time =&gt; time.getSeconds()\n    }\n  };\n&lt;/script&gt;\n</code></pre>\n<p>Of course, you could use <code>leftPad</code> inside the computed properties instead of in the template. There&#39;s no hard and fast rule about when you should use expressions with helpers versus when you should use computed properties â€“ do whatever makes your component easier for the next developer to understand.</p>\n<blockquote>\n<p>Helper functions should be <em>pure</em> â€“ in other words, they should not have side-effects, and their returned value should only depend on their arguments.</p>\n</blockquote>\n<h3 id=\"custom-methods\">Custom methods</h3>\n<p>In addition to the <a href=\"#component-api\">built-in methods</a>, you can add methods of your own:</p>\n<pre><code class=\"lang-html\">&lt;script&gt;\n  export default {\n    methods: {\n      say: function ( message ) {\n        alert( message ); // again, please don&#39;t do this\n      }\n    }\n  };\n&lt;/script&gt;\n</code></pre>\n<p>These become part of the component&#39;s API:</p>\n<pre><code class=\"lang-js\">import MyComponent from &#39;./MyComponent.html&#39;;\n\nvar component = new MyComponent({\n  target: document.querySelector( &#39;main&#39; )\n});\n\ncomponent.say( &#39;ðŸ‘‹&#39; );\n</code></pre>\n<p>Methods (whether built-in or custom) can also be called inside <a href=\"#event-handlers\">event handlers</a>:</p>\n<pre><code class=\"lang-html\">&lt;button on:click=&#39;say(&quot;hello&quot;)&#39;&gt;say hello!&lt;/button&gt;\n</code></pre>\n<h3 id=\"custom-event-handlers\">Custom event handlers</h3>\n<p>Soon, we&#39;ll learn about <a href=\"#event-handlers\">event handlers</a> â€“ if you want, skip ahead to that section first then come back here!</p>\n<p>Most of the time you can make do with the standard DOM events (the sort you&#39;d add via <code>element.addEventListener</code>, such as <code>click</code>) but sometimes you might need custom events to handle gestures, for example.</p>\n<p>Custom events are just functions that take a node and a callback as their argument, and return an object with a <code>teardown</code> method that gets called when the element is removed from the page:</p>\n<pre><code class=\"lang-html\">&lt;button on:longpress=&#39;set({ done: true })&#39;&gt;click and hold&lt;/button&gt;\n\n{{#if done}}\n  &lt;p&gt;clicked and held&lt;/p&gt;\n{{/if}}\n\n&lt;script&gt;\n  export default {\n    events: {\n      longpress ( node, callback ) {\n        function onmousedown ( event ) {\n          const timeout = setTimeout( () =&gt; callback( event ), 1000 );\n\n          function cancel () {\n            clearTimeout( timeout );\n            node.removeEventListener( &#39;mouseup&#39;, cancel, false );\n          }\n\n          node.addEventListener( &#39;mouseup&#39;, cancel, false );\n        }\n\n        node.addEventListener( &#39;mousedown&#39;, onmousedown, false );\n\n        return {\n          teardown () {\n            node.removeEventListener( &#39;mousedown&#39;, onmousedown, false );\n          }\n        };\n      }\n    }\n  };\n&lt;/script&gt;\n</code></pre>\n<h3 id=\"nested-components\">Nested components</h3>\n<p>So far, we&#39;ve been working with single standalone components. But if you tried to put your entire application in one component it would quickly become unwieldy.</p>\n<p>Fortunately, Svelte components can be <em>nested</em>:</p>\n<pre><code class=\"lang-html\">&lt;div class=&#39;widget-container&#39;&gt;\n  &lt;Widget foo bar=&#39;static&#39; baz=&#39;{{dynamic}}&#39;/&gt;\n&lt;/div&gt;\n\n&lt;script&gt;\n  import Widget from &#39;./Widget.html&#39;;\n\n  export default {\n    data () {\n      return {\n        dynamic: &#39;this can change&#39;\n      }\n    },\n\n    components: {\n      Widget\n    }\n  };\n&lt;/script&gt;\n</code></pre>\n<p>The example above is equivalent to the following...</p>\n<pre><code class=\"lang-js\">import Widget from &#39;./Widget.html&#39;;\n\nconst widget = new Widget({\n  target: document.querySelector( &#39;.widget-container&#39; ),\n  data: {\n    foo: true,\n    bar: &#39;static&#39;,\n    baz: &#39;this can change&#39;\n  }\n});\n</code></pre>\n<p>...except that Svelte will ensure that the value of <code>baz</code> is kept in sync with the value of <code>dynamic</code> in the parent component, and takes care of tearing down the child component when the parent is torn down.</p>\n<blockquote>\n<p>Component names should be capitalised, following the widely-used JavaScript convention of capitalising constructor names. It&#39;s also an easy way to distinguish components from elements in your template.</p>\n</blockquote>\n","metadata":{"title":"Behaviours"},"subsections":[{"slug":"default-data","title":"Default data"},{"slug":"computed-properties","title":"Computed properties"},{"slug":"lifecycle-hooks","title":"Lifecycle hooks"},{"slug":"helpers","title":"Helpers"},{"slug":"custom-methods","title":"Custom methods"},{"slug":"custom-event-handlers","title":"Custom event handlers"},{"slug":"nested-components","title":"Nested components"}],"slug":"behaviour"},{"html":"<p>Directives are element or component-level instructions to Svelte. They look like attributes, except with a <code>:</code> character.</p>\n<h3 id=\"event-handlers\">Event handlers</h3>\n<p>In most applications, you&#39;ll need to respond to the user&#39;s actions. In Svelte, this is done with the <code>on:[event]</code> directive.</p>\n<pre><code class=\"lang-html\">&lt;p&gt;Count: {{count}}&lt;/p&gt;\n&lt;button on:click=&#39;set({ count: count + 1 })&#39;&gt;+1&lt;/button&gt;\n</code></pre>\n<pre><code class=\"lang-hidden-data\">{\n  &quot;count&quot;: 0\n}\n</code></pre>\n<p>When the user clicks the button, Svelte calls <code>component.set(...)</code> with the provided arguments. You can call any method belonging to the component (whether <a href=\"#component-api\">built-in</a> or <a href=\"#custom-methods\">custom</a>), and any data property (or computed property) that&#39;s in scope:</p>\n<pre><code class=\"lang-html\">&lt;p&gt;Select a category:&lt;/p&gt;\n\n{{#each categories as category}}\n  &lt;button on:click=&#39;select( category )&#39;&gt;select {{category}}&lt;/button&gt;\n{{/each}}\n\n&lt;script&gt;\n  export default {\n    data () {\n      return {\n        categories: [\n          &#39;animal&#39;,\n          &#39;vegetable&#39;,\n          &#39;mineral&#39;\n        ]\n      }\n    },\n\n    methods: {\n      select ( name ) {\n        alert( `selected ${name}` );\n      }\n    }\n  };\n&lt;/script&gt;\n</code></pre>\n<p>You can also access the <code>event</code> object in the method call:</p>\n<pre><code class=\"lang-html\">&lt;div on:mousemove=&#39;set({ x: event.clientX, y: event.clientY })&#39;&gt;\n  coords: {{x}},{{y}}\n&lt;/div&gt;\n\n&lt;style&gt;\n  div {\n    border: 1px solid purple;\n    width: 100%;\n    height: 100%;\n  }\n&lt;/style&gt;\n</code></pre>\n<p>The target node can be referenced as <code>this</code>, meaning you can do this sort of thing:</p>\n<pre><code class=\"lang-html\">&lt;input on:focus=&#39;this.select()&#39;&gt;\n</code></pre>\n<h3 id=\"custom-events\">Custom events</h3>\n<p>You can define your own custom events to handle complex user interactions like dragging and swiping. See the earlier section on <a href=\"#custom-event-handlers\">custom event handlers</a> for more information.</p>\n<h3 id=\"component-events\">Component events</h3>\n<p>Events are an excellent way for <a href=\"#nested-components\">nested components</a> to communicate with their parents. Let&#39;s revisit our earlier example, but turn it into a <code>&lt;CategoryChooser&gt;</code> component:</p>\n<pre><code class=\"lang-html-no-repl\">&lt;!-- CategoryChooser.html --&gt;\n&lt;p&gt;Select a category:&lt;/p&gt;\n\n{{#each categories as category}}\n  &lt;button on:click=&#39;fire( &quot;select&quot;, { category } )&#39;&gt;select {{category}}&lt;/button&gt;\n{{/each}}\n\n&lt;script&gt;\n  export default {\n    data () {\n      return {\n        categories: [\n          &#39;animal&#39;,\n          &#39;vegetable&#39;,\n          &#39;mineral&#39;\n        ]\n      }\n    }\n  };\n&lt;/script&gt;\n</code></pre>\n<p>When the user clicks a button, the component will fire a <code>select</code> event, where the <code>event</code> object has a <code>category</code> property. Any component that nests <code>&lt;CategoryChooser&gt;</code> can listen for events like so:</p>\n<pre><code class=\"lang-html-no-repl\">&lt;CategoryChooser on:select=&#39;playTwentyQuestions( event.category )&#39;/&gt;\n\n&lt;script&gt;\n  import CategoryChooser from &#39;./CategoryChooser.html&#39;;\n\n  export default {\n    components: {\n      CategoryChooser\n    },\n\n    methods: {\n      playTwentyQuestions ( category ) {\n        // TODO implement\n      }\n    }\n  };\n&lt;/script&gt;\n</code></pre>\n<h3 id=\"refs\">Refs</h3>\n<p>Refs are a convenient way to store a reference to particular DOM nodes or components. Declare a ref with <code>ref:[name]</code>, and access it inside your component&#39;s methods with <code>this.refs.[name]</code>:</p>\n<pre><code class=\"lang-html\">&lt;canvas ref:canvas width=&#39;200&#39; height=&#39;200&#39;&gt;&lt;/canvas&gt;\n\n&lt;script&gt;\n  export default {\n    oncreate () {\n      const canvas = this.refs.canvas;\n      const ctx = canvas.getContext( &#39;2d&#39; );\n\n      let torndown = false;\n      this.on( &#39;teardown&#39;, () =&gt; torndown = true );\n\n      function loop () {\n        if ( torndown ) return;\n        requestAnimationFrame( loop );\n\n        const imageData = ctx.getImageData( 0, 0, canvas.width, canvas.height );\n\n        for ( let p = 0; p &lt; imageData.data.length; p += 4 ) {\n          const i = p / 4;\n          const x = i % canvas.width;\n          const y = i / canvas.height &gt;&gt;&gt; 0;\n\n          const t = window.performance.now();\n\n          const r = 64 + ( 128 * x / canvas.width ) + ( 64 * Math.sin( t / 1000 ) );\n          const g = 64 + ( 128 * y / canvas.height ) + ( 64 * Math.cos( t / 1000 ) );\n          const b = 128;\n\n          imageData.data[ p + 0 ] = r;\n          imageData.data[ p + 1 ] = g;\n          imageData.data[ p + 2 ] = b;\n          imageData.data[ p + 3 ] = 255;\n        }\n\n        ctx.putImageData( imageData, 0, 0 );\n      }\n\n      loop();\n    }\n  }\n&lt;/script&gt;\n</code></pre>\n<blockquote>\n<p>Since only one element or component can occupy a given <code>ref</code>, don&#39;t use them in <code>{{#each ...}}</code> blocks. It&#39;s fine to use them in <code>{{#if ...}}</code> blocks however.</p>\n</blockquote>\n<h3 id=\"two-way-binding\">Two-way binding</h3>\n<p>It&#39;s currently fashionable to avoid two-way binding on the grounds that it creates all sorts of hard-to-debug problems and slows your application down, and that a one-way top-down data flow is &#39;easier to reason about&#39;. This is in fact high grade nonsense. It&#39;s true that two-way binding done <em>badly</em> has all sorts of issues, and that very large apps benefit from the discipline of a not permitting deeply nested components to muck about with state that might affect distant parts of the app. But when used correctly, two-way binding simplifies things greatly.</p>\n<p>Bindings are declared with the <code>bind:[attribute]</code> directive:</p>\n<pre><code class=\"lang-html\">&lt;input bind:value=&#39;name&#39; placeholder=&#39;enter your name&#39;&gt;\n&lt;p&gt;Hello {{name || &#39;stranger&#39;}}!&lt;/p&gt;\n</code></pre>\n<blockquote>\n<p>Two-way binding is not yet fully implemented. Check back soon for the full list of available bindings!</p>\n</blockquote>\n<p>As well as DOM elements, you can bind to component data properties:</p>\n<pre><code class=\"lang-html-no-repl\">&lt;CategoryChooser bind:category=&#39;category&#39;/&gt;\n</code></pre>\n<p>If the attribute and the bound property share a name, you can use this shorthand:</p>\n<pre><code class=\"lang-html-no-repl\">&lt;CategoryChooser bind:category/&gt;\n</code></pre>\n<p>Here is a complete example of using two way bindings with a form: </p>\n<pre><code class=\"lang-html\">&lt;form on:submit=&#39;handleSubmit( event )&#39;&gt;\n  &lt;input bind:value=&#39;test&#39; type=&#39;text&#39;&gt;\n  &lt;button type=&#39;submit&#39;&gt;Store&lt;/button&gt;\n&lt;/form&gt;\n\n&lt;script&gt;\nexport default {\n  methods: {\n    handleSubmit: function ( event ) {\n      // prevent the page from reloading\n      event.preventDefault();\n\n      var value = this.get( &#39;test&#39; );\n      console.log( &#39;value&#39;, value );\n    }\n  }\n};\n&lt;/script&gt;\n</code></pre>\n","metadata":{"title":"Element directives"},"subsections":[{"slug":"event-handlers","title":"Event handlers"},{"slug":"custom-events","title":"Custom events"},{"slug":"component-events","title":"Component events"},{"slug":"refs","title":"Refs"},{"slug":"two-way-binding","title":"Two-way binding"}],"slug":"element-directives"},{"html":"<p>TODO...</p>\n","metadata":{"title":"Plugins"},"subsections":[],"slug":"plugins"},{"html":"<p>So far, we&#39;ve discussed creating Svelte components <em>on the client</em>, which is to say the browser. But you can also render Svelte components in Node.js. This can result in better perceived performance as it means the application starts rendering while the page is still downloading, before any JavaScript executes. It also has SEO advantages in some cases, and can be beneficial for people running older browsers that can&#39;t or won&#39;t run your JavaScript for whatever reason.</p>\n<h3 id=\"rendering-html\">Rendering HTML</h3>\n<p>To use the server-side renderer, we must first <em>register</em> it. This means that when you <code>require</code> a component <code>.html</code> file, it gets intercepted by the SSR compiler:</p>\n<pre><code class=\"lang-js\">require( &#39;svelte/ssr/register&#39; );\n</code></pre>\n<p>After that, you can load components like so:</p>\n<pre><code class=\"lang-js\">const thing = require( &#39;./components/Thing.html&#39; );\n</code></pre>\n<p>Components have a different API in Node.js â€“ rather than creating instances with <code>set(...)</code> and <code>get(...)</code> methods, a component is an object with a <code>render(data)</code> method which returns HTML (the <code>data</code> object is the same as you would use when instantiating a component in the browser, and is optional):</p>\n<pre><code class=\"lang-js\">const data = { answer: 42 };\nconst html = thing.render( data );\n</code></pre>\n<p>Any <a href=\"#default-data\">default data</a>, <a href=\"#computed-properties\">computed properties</a>, <a href=\"#helpers\">helpers</a> and <a href=\"#nested-components\">nested components</a> will work as expected.</p>\n<blockquote>\n<p>The SSR compiler will generate a CommonJS module for each of your components â€“ meaning that <code>import</code> and <code>export</code> statements are converted into their <code>require</code> and <code>module.exports</code> equivalents. If your components have non-component dependencies, they must also work as CommonJS modules in Node. If you&#39;re using ES2015 modules, we recommend <a href=\"https://github.com/benjamn/reify\">reify</a> for automatically converting them to CommonJS.</p>\n</blockquote>\n<h3 id=\"rendering-css\">Rendering CSS</h3>\n<p>You can also render your component&#39;s (<a href=\"#scoped-styles\">scoped</a>) CSS, including that of any nested components:</p>\n<pre><code class=\"lang-js\">const { css, components } = thing.renderCss();\n</code></pre>\n<p>You could put the resulting <code>css</code> in a separate stylesheet, or include them in the page inside a <code>&lt;style&gt;</code> tag. If you do this, you will probably want to prevent the client-side compiler from including the CSS again. For <code>svelte-cli</code>, use the <code>--no-css</code> flag. In build tool integrations like <code>rollup-plugin-svelte</code>, pass the <code>css: false</code> option.</p>\n<blockquote>\n<p>The <code>components</code> array contains an object for each nested component that contains styles, allowing you to dedupe styles across multiple top-level components. Most of the time, you won&#39;t need to do this.</p>\n</blockquote>\n","metadata":{"title":"Server-side rendering"},"subsections":[{"slug":"rendering-html","title":"Rendering HTML"},{"slug":"rendering-css","title":"Rendering CSS"}],"slug":"server-side-rendering"},{"html":"<p>This documentation is still a work-in-progress, like Svelte itself. If there are particular things that are missing or could be improved, then <a href=\"https://github.com/sveltejs/svelte.technology\">please raise an issue on GitHub</a>!</p>\n","metadata":{"title":"TODO..."},"subsections":[],"slug":"still-to-come"}];

var template$1 = (function () {
	return {
		data () {
			return {
				contents
			};
		}
	};
}());

var GuideContents = {};

GuideContents.filename = "/www/SVELTE/svelte.technology/shared/components/GuideContents.html";

GuideContents.data = function () {
	return template$1.data();
};

GuideContents.render = function ( root, options ) {
	root = Object.assign( template$1.data(), root || {} );
	
	return `<ul class="guide-toc" svelte-1375179214>${ root.contents.map( section => `<li svelte-1375179214><a class="section" href="/guide#${section.slug}" svelte-1375179214>${__escape$1( section.metadata.title )}</a>
				${ section.subsections.map( subsection => `<a class="subsection" href="/guide#${subsection.slug}" svelte-1375179214>${__escape$1( subsection.title )}</a>` ).join( '' )}</li>` ).join( '' )}</ul>`;
};

GuideContents.renderCss = function () {
	var components = [];
	
	components.push({
		filename: GuideContents.filename,
		css: "\n\t[svelte-1375179214].guide-toc, [svelte-1375179214] .guide-toc {\n\t\tmargin: 0;\n\t\tpadding: 0;\n\t}\n\n\t[svelte-1375179214].guide-toc li, [svelte-1375179214] .guide-toc li {\n\t\tdisplay: block;\n\t\tmargin: 0 0 2em 0;\n\t}\n\n\t[svelte-1375179214].guide-toc .section, [svelte-1375179214] .guide-toc .section {\n\t\tdisplay: block;\n\t\tfont-weight: 700;\n\t\tcolor: #333;\n\t\tfont-size: 1.2rem;\n\t\tmargin: 0 0 0.15em 0;\n\t}\n\n\t[svelte-1375179214].guide-toc .subsection, [svelte-1375179214] .guide-toc .subsection {\n\t\tdisplay: block;\n\t\tfont-weight: 500;\n\t\tcolor:#727272;\n\t\tfont-size: 1em;\n\t\tmargin: 0 0 0.15em 0;\n\t}\n",
		map: null // TODO
	});
	
	return {
		css: components.map( x => x.css ).join( '\n' ),
		map: null,
		components
	};
};

var escaped$1 = {
	'"': '&quot;',
	"'": '&#39;',
	'&': '&amp;',
	'<': '&lt;',
	'>': '&gt;'
};

function __escape$1 ( html ) {
	return String( html ).replace( /["'&<>]/g, match => escaped$1[ match ] );
}

var template = (function () {
	return {
		components: {
			GuideContents
		}
	};
}());

var Guide = {};

Guide.filename = "/www/SVELTE/svelte.technology/shared/routes/Guide.html";

Guide.data = function () {
	return {};
};

Guide.render = function ( root, options ) {
	root = root || {};
	
	return `<div class="content" svelte-1948683836>${ root.sections.map( section => `<section id="${section.slug}" svelte-1948683836><h2 svelte-1948683836>${__escape( section.metadata.title )}</h2>
				${section.html}</section>` ).join( '' )}</div>
	
	<div class="sidebar" svelte-1948683836>${template.components.GuideContents.render({})}</div>`;
};

Guide.renderCss = function () {
	var components = [];
	
	components.push({
		filename: Guide.filename,
		css: "\n\t[svelte-1948683836].sidebar, [svelte-1948683836] .sidebar {\n\t\tposition: fixed;\n\t\tleft: 0;\n\t\ttop: 4em;\n\t\twidth: 14em;\n\t\theight: calc(100vh - 4em);\n\t\tdisplay: none;\n\t\tfont-family: Rajdhani;\n\t\toverflow-y: auto;\n\t\tpadding: 2em 1em 2em 1.5em;\n\t}\n\n\t[svelte-1948683836].content, [svelte-1948683836] .content {\n\t\twidth: 100%;\n\t\tpadding: 1em;\n\t}\n\n\th2[svelte-1948683836], [svelte-1948683836] h2 {\n\t\tpadding: 1rem 0 0 0;\n\t\tmargin: 0 0 1rem 0;\n\t\tfont-size: 2.4em;\n\t\tfont-weight: 400;\n\t}\n\n\th3[svelte-1948683836], [svelte-1948683836] h3 {\n\t\tfont-size: 1.2em;\n\t\tfont-weight: 800;\n\t\tmargin: 2em 0 0 0;\n\t}\n\n\tp[svelte-1948683836], [svelte-1948683836] p {\n\t\tmargin: 0 0 1em 0;\n\t\tfont-family: Roboto;\n\t\tfont-weight: 300;\n\t\tcolor: #181818;\n\t\tline-height: 1.5;\n\t}\n\n\t[svelte-1948683836].content a, [svelte-1948683836] .content a {\n\t\tborder-bottom: 1px solid #e3d9d9;\n\t}\n\n\tstrong[svelte-1948683836], [svelte-1948683836] strong {\n\t\tfont-weight: 500;\n\t}\n\n\tcode[svelte-1948683836], [svelte-1948683836] code {\n\t\tbackground-color: #f9f9f9;\n\t\tpadding: 0.2em 0.4em;\n\t\tborder-radius: 3px;\n\t}\n\n\tsection[svelte-1948683836]:first-child h3, [svelte-1948683836] section:first-child h3 {\n\t\tborder: none;\n\t}\n\n\tsection[svelte-1948683836], [svelte-1948683836] section {\n\t\tborder-bottom: 1px solid #eee;\n\t\tmax-width: 64em;\n\t\tmargin: 0 auto 2em auto;\n\t\tpadding: 0 0 4em 0;\n\t}\n\n\tsection[svelte-1948683836]:last-child, [svelte-1948683836] section:last-child {\n\t\tborder: none;\n\t}\n\n\tsection[svelte-1948683836] > pre, [svelte-1948683836] section > pre, [svelte-1948683836].CodeMirror, [svelte-1948683836] .CodeMirror {\n\t\tbackground-color: #f9f9f9;\n\t\tborder-left: 2px solid #eee;\n\t\tpadding: 8px;\n\t\tmargin: 0 0 1em 0;\n\t}\n\n\tsection[svelte-1948683836] > pre, [svelte-1948683836] section > pre {\n\t\tpadding: 12px 8px 12px 12px;\n\t\tborder-radius: 3px;\n\t}\n\n\tp[svelte-1948683836], [svelte-1948683836] p, ul[svelte-1948683836], [svelte-1948683836] ul {\n\t\tmax-width: 48em;\n\t}\n\n\tli[svelte-1948683836], [svelte-1948683836] li {\n\t\tmargin: 0;\n\t}\n\n\t[svelte-1948683836].open-in-repl, [svelte-1948683836] .open-in-repl {\n\t\tposition: absolute;\n\t\tz-index: 99;\n\t\tright: 0;\n\t}\n\n\t[svelte-1948683836].open-in-repl::after, [svelte-1948683836] .open-in-repl::after {\n\t\tposition: absolute;\n\t\tcontent: 'open in repl';\n\t\ttext-transform: uppercase;\n\t\tright: 0.5em;\n\t\ttop: 0.5em;\n\t\tborder: 1px solid rgba(0,0,0,0.1);\n\t\tfont-family: Rajdhani;\n\t\tfont-weight: 500;\n\t\ttext-align: center;\n\t\twhite-space: pre;\n\t\tpadding: 0.25em 0.5em 0.1em 0.5em;\n\t\tline-height: 1;\n\t\tborder-radius: 0.1em;\n\t\tcolor: rgba(170,30,30,0.8);\n\t\tbackground-color: rgb(253,242,242);\n\t}\n\n\t[svelte-1948683836].open-in-repl:hover::after, [svelte-1948683836] .open-in-repl:hover::after {\n\t\tcolor: white;\n\t\tbackground-color: rgba(170,30,30,1);\n\t}\n\n\tblockquote[svelte-1948683836], [svelte-1948683836] blockquote {\n\t\tposition: relative;\n\t\tcolor: #999;\n\t\tmargin: 1em 0;\n\t\tpadding: 0.5em 0 0.5em 2em;\n\t\tmax-width: 48em;\n\t\tborder-top: 1px solid #eee;\n\t\tborder-bottom: 1px solid #eee;\n\t}\n\n\tblockquote[svelte-1948683836] p, [svelte-1948683836] blockquote p {\n\t\tcolor: #666;\n\t}\n\n\tblockquote[svelte-1948683836] p:last-child, [svelte-1948683836] blockquote p:last-child {\n\t\tmargin: 0;\n\t}\n\n\tblockquote[svelte-1948683836]::before, [svelte-1948683836] blockquote::before {\n\t\tcontent: '!';\n\t\tposition: absolute;\n\t\tleft: 0.5em;\n\t\ttop: 0.8em;\n\t\tcolor: rgba(170,0,0, 0.7);\n\t\tfont-size: 0.8em;\n\t\tfont-weight: 800;\n\t\twidth: 1em;\n\t\theight: 1em;\n\t\ttext-align: center;\n\t\tline-height: 1;\n\t\tpadding: 0.15em 0.1em 0.1em 0.1em;\n\t\tborder-radius: 50%;\n\t\tborder: 2px solid rgba(170,30,30,0.7);\n\t}\n\n\t@media (min-width: 768px) {\n\t\t[svelte-1948683836].sidebar, [svelte-1948683836] .sidebar {\n\t\t\tdisplay: block;\n\t\t}\n\n\t\t[svelte-1948683836].content, [svelte-1948683836] .content {\n\t\t\tpadding: 2em 2em 2em 16em;\n\t\t}\n\t}\n\n",
		map: null // TODO
	});
	
	var seen = {};
	
	function addComponent ( component ) {
		var result = component.renderCss();
		result.components.forEach( x => {
			if ( seen[ x.filename ] ) return;
			seen[ x.filename ] = true;
			components.push( x );
		});
	}
	
	addComponent( template.components.GuideContents );
	
	return {
		css: components.map( x => x.css ).join( '\n' ),
		map: null,
		components
	};
};

var escaped = {
	'"': '&quot;',
	"'": '&#39;',
	'&': '&amp;',
	'<': '&lt;',
	'>': '&gt;'
};

function __escape ( html ) {
	return String( html ).replace( /["'&<>]/g, match => escaped[ match ] );
}

module.exports = Guide;
